<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="styles/stylenav.css">
    <link rel="stylesheet" href="styles/stylehomepage.css">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body>

<div id="app">
    <div class="main-container">
    <div class="container-fluid">
        <!--Nav start-->
        <div class="row">
            <div class="col-12 background" :style="{ backgroundImage: `url(${backgroundImage})` }">
                <p class="background-text">{{ displayedText }}</p>
            </div>
        </div>

        <div id="nav-component"></div>
        <!--Nav end-->

        <div class="welcome-back">
            <p style="font-size: 30px;">Welcome back, {{username}}!<p>
        </div>

        <div class="inventory-overview">
            <h2>Your Inventory Overview</h2>
            <div class="carousel-container" v-if="inventoryItems.length > 0"
                @wheel.prevent="onScroll"
                @mousedown="handleDragStart"
                @mousemove="handleDragMove"
                @mouseup="handleDragEnd"
                @mouseleave="handleDragEnd">
                <div class="carousel-stage">
                    <div class="inventory-card" 
                        :class="{ 'warning': isNearExpiry(item.expiry), 'no-warning': !isNearExpiry(item.expiry) }" 
                        v-for="(item, index) in inventoryItems" 
                        :key="item.id" 
                        :style="getCardStyle(index)">

                        <!-- Top Warning Banner -->
                        <div v-if="isNearExpiry(item.expiry)" class="expiry-warning">
                            Expiry in Less Than {{ getMonthsUntilExpiry(item.expiry) }} Months
                        </div>

                        <!-- Original Card Content -->
                        <div class="card-content">
                            <img :src="item.image" alt="Inventory Image" class="inventory-image">
                            <div class="inventory-info">
                                <h3>{{ item.name }}</h3>
                                <p>Expiry: {{ item.expiry }}</p>
                                <p>Quantity: {{ item.quantity }}</p>
                            </div>
                        </div>

                        <!-- Bottom Sell Button -->
                        <div v-if="isNearExpiry(item.expiry)" class="sell-now">
                            <a href="new-listing.html" class="sell-button">Sell Now</a>
                        </div>
                    </div>
                </div>
                <button class="nav-button prev" @click="prevSlide">←</button>
                <button class="nav-button next" @click="nextSlide">→</button>
            </div>

            <!-- Message for no items in inventory -->
            <div v-else class="no-inventory">
                <p>No Products In Inventory Yet</p>
                <a href="inventory.html" class="inventory-button">Go to Inventory</a>
            </div>
        </div>

        <br><br><br><br>
        
    </div>
    </div>

    <div class="graph-section">
        <div class="row">
            <div class="col-6">
                <h3 >Weekly Traffic Overview</h3>
                <canvas id="trafficChart"></canvas>
            </div>
            <div class="col-6">    
                <h3>Sales Overview (Profit and Expenses)</h3>
                <canvas id="salesChart"></canvas>
            </div>
    
        </div>
    </div>
</div>



<!-- Scripts -->
<script src="./navbar.js" type="module"></script>
<script src="./homepage.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


<script type="module">
    import { app } from "./firebase.js";
    import { onAuthStateChanged ,getAuth } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
    import { getFirestore, doc, getDoc, collection, query, where, getDocs, onSnapshot } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore.js";
    import { getStorage } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-storage.js";
   
    const auth = getAuth(app);
    const db = getFirestore(app);
    const storage = getStorage(app);


    let userUID;  // Declare a global variable to store the UID
    let userItemIds;

    const vueApp = Vue.createApp({
        data() {
            return {
                fullText: "",
                displayedText: "",
                backgroundImage: "",
                typingSpeed: 100,
                inventoryItems: [], // Array to hold inventory items
                currentIndex: 0,
                isScrolling: false,
                scrollTimeout: null,
                isDragging: false,
                startX: 0,
                scrollAccumulator: 0,
                SCROLL_THRESHOLD: 100,
                username: '',
            };
        },
        mounted() {
            onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userUID = user.uid;
                        console.log("User UID:", userUID);
                        this.fetchUserData(); // Call fetchUserData within Vue's context
                        this.fetchInventoryData(user.uid);
                    } else {
                        alert("You need to be logged in to list an item.");
                    }
                }),
            this.startTypingEffect();
            this.getTimeAndSetBackground();
        },
        methods: {
            async getTimeAndSetBackground() {
                    try {
                        const response = await fetch("https://timeapi.io/api/time/current/coordinate?latitude=1.364917&longitude=103.822872");
                        const data = await response.json();
                        
                        // Parse the datetime string to get the hour
                        // const dateTime = new Date(data.datetime);
                        const hour = data.hour;

                        // Determine time of day and set background and text
                        if (hour >= 6 && hour < 12) {
                            // Morning
                            this.fullText = "Good Morning, Rise and Shine";
                            this.backgroundImage = "./images/nav/morning3.png"; // Replace with your morning image path
                        } else if (hour >= 12 && hour < 18) {
                            // Afternoon
                            this.fullText = "Good Afternoon, It's Fun O'clock!";
                            this.backgroundImage = "./images/nav/afternoon.png"; // Replace with your afternoon image path
                        } else {
                            // Evening/Night
                            this.fullText = "Hello. The Night Is Still Young.";
                            this.backgroundImage = "./images/nav/night3.png"; // Replace with your evening/night image path
                        }

                        this.startTypingEffect(); // Start typing effect if needed
                    } catch (error) {
                        console.error("Error fetching time data:", error);
                    }
                },
                startTypingEffect() {
                    let index = 0;
                    this.displayedText = "";

                    // Clear any existing interval to prevent overlap
                    if (this.typingInterval) {
                        clearInterval(this.typingInterval);
                    }

                    // Start the typing interval
                    this.typingInterval = setInterval(() => {
                        this.displayedText += this.fullText.charAt(index);
                        index++;

                        // Stop the interval when the text is fully typed
                        if (index === this.fullText.length) {
                            clearInterval(this.typingInterval);
                        }
                    }, this.typingSpeed);
                },
                async fetchUserData() {
                    try {
                        // Retrieve UID from sessionStorage if it's stored there
                        const uid = userUID // Use global UID or sessionStorage

                        if (uid) {
                            const userDocRef = doc(db, "users", uid);
                            const userDoc = await getDoc(userDocRef);

                            if (userDoc.exists()) {
                                const userData = userDoc.data();
                                console.log("User Data:", userData);
                                this.username = userData.username;
                            } else {
                                console.log("No user data found in Firestore.");
                            }
                        } else {
                            console.log("User UID not found.");
                        }
                    } catch (error) {
                        console.error("Error fetching user data:", error);
                    }
                },
                async fetchInventoryData(uid) {
                    try {
                        const inventoryRef = collection(db, "inventory");
                        const q = query(inventoryRef, where("userUID", "==", uid)); // Pass userUID directly
                        const querySnapshot = await getDocs(q);
                        
                        this.inventoryItems = []; // Clear existing items to avoid duplication
                        querySnapshot.forEach((doc) => {
                            const item = doc.data();
                            this.inventoryItems.push({
                                id: doc.id,
                                ...item
                            });
                        });
                    } catch (error) {
                        console.error("Error fetching inventory:", error);
                    }
                },
                nextSlide() {
                    if (!this.isScrolling) {
                        this.isScrolling = true;
                        this.currentIndex = this.currentIndex === this.inventoryItems.length - 1 ? 0 : this.currentIndex + 1;
                        setTimeout(() => {
                        this.isScrolling = false;
                        }, 500); // Adjust this delay to control slide transition speed
                    }
                },
                prevSlide() {
                    if (!this.isScrolling) {
                        this.isScrolling = true;
                        this.currentIndex = this.currentIndex === 0 ? this.inventoryItems.length - 1 : this.currentIndex - 1;
                        setTimeout(() => {
                        this.isScrolling = false;
                        }, 500); // Adjust this delay to control slide transition speed
                    }
                },
                getCardStyle(index) {
                    const diff = index - this.currentIndex;
                    const spacing = 60;
                    const rotation = 45;
                    
                    if (diff === 0) {
                        return {
                        transform: 'translate(-50%, -50%) scale(1) rotateY(0deg)',
                        zIndex: 2
                        };
                    } else if (diff === 1 || (diff === -this.inventoryItems.length + 1)) {
                        return {
                        transform: `translate(${spacing}%, -50%) scale(0.8) rotateY(${rotation}deg)`,
                        zIndex: 1
                        };
                    } else if (diff === -1 || (diff === this.inventoryItems.length - 1)) {
                        return {
                        transform: `translate(-${spacing + 100}%, -50%) scale(0.8) rotateY(-${rotation}deg)`,
                        zIndex: 1
                        };
                    } else {
                        return {
                        transform: 'translate(-50%, -50%) scale(0) rotateY(0deg)',
                        zIndex: 0
                        };
                        
                        }
                },
                onScroll(event) {
                    // Clear any existing timeout
                    clearTimeout(this.scrollTimeout);
                    
                    // Accumulate the scroll delta
                    this.scrollAccumulator += event.deltaY;
                    
                    // Check if we've reached the threshold in either direction
                    if (Math.abs(this.scrollAccumulator) >= this.SCROLL_THRESHOLD) {
                        if (this.scrollAccumulator > 0) {
                        this.nextSlide();
                        } else {
                        this.prevSlide();
                        }
                        // Reset the accumulator
                        this.scrollAccumulator = 0;
                    }
                    
                    // Reset accumulator if no scroll events for a while
                    this.scrollTimeout = setTimeout(() => {
                        this.scrollAccumulator = 0;
                    }, 150);
                },
                handleDragStart(event) {
                    this.isDragging = true;
                    this.startX = event.clientX;
                },
                handleDragMove(event) {
                    if (!this.isDragging) return;
                    
                    const currentX = event.clientX;
                    const diff = this.startX - currentX;
                    
                    if (Math.abs(diff) > 50) { // Threshold for drag distance
                        if (diff > 0) {
                        this.nextSlide();
                        } else {
                        this.prevSlide();
                        }
                        this.isDragging = false;
                    }
                },
                handleDragEnd() {
                    this.isDragging = false;
                },
                isNearExpiry(expiryDate) {
                    const today = new Date();
                    const expiry = new Date(expiryDate);
                    const monthsDiff = (expiry - today) / (1000 * 60 * 60 * 24 * 30.44); // Average month length
                    return monthsDiff <= 3 && monthsDiff > 0;
                },
                getMonthsUntilExpiry(expiryDate) {
                const today = new Date();
                const expiry = new Date(expiryDate);
                const monthsDiff = Math.ceil((expiry - today) / (1000 * 60 * 60 * 24 * 30.44));
                return monthsDiff;
                }
        }
    }).mount('#app');
    
    auth.onAuthStateChanged((user) => {
            if (user) {
                // User is signed in, get the UID
                userUID = user.uid;
                console.log("Logged-in user UID:", userUID);

                getUserItemIds(userUID).then((itemIds) => {
                userItemIds = itemIds; // Set the global item IDs array
                // Proceed with the onSnapshot listener
});

                // You can now pass `uid` to functions or use it to filter listings for this specific user
            } else {
                // No user is signed in
                console.log("No user is logged in");
            }
        });


    // Create Chart instances
    let trafficData = [0, 0, 0, 0, 0, 0, 0];
    let profitData = {
    'dogFood': 0,
    'dogAccessories': 0,
    'dogToys': 0
};

// Function to get user's listed item IDs from Firestore
async function getUserItemIds(userId) {
    const userItemsRef = collection(db, 'marketplace'); // Replace 'items' with your collection name
    console.log('User ID:', userId);
    const q = query(userItemsRef, where('userId', '==', userId)); // Assuming 'userId' field in your items

    const querySnapshot = await getDocs(q);
    const itemIds = [];
    querySnapshot.forEach((doc) => {
        itemIds.push(doc.id); // Collect item IDs
    });
    return itemIds;
}

// Call this function and set up the listener once you have the item IDs

// Initialize the chart with empty data before setting up the Firestore listener
const trafficCtx = document.getElementById('trafficChart')?.getContext('2d');
let trafficChart;

if (trafficCtx) {
    trafficChart = new Chart(trafficCtx, {
        type: 'line',
        data: {
            labels: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            datasets: [{
                label: 'Number of Visits',
                data: [0, 0, 0, 0, 0, 0, 0], // Initial empty data
                backgroundColor: 'rgba(54, 162, 235, 0.6)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
}

// Firestore real-time listener
const trafficRef = collection(db, 'itemViews');
onSnapshot(trafficRef, (snapshot) => {
    // Reset traffic data for real-time updates
    trafficData = [0, 0, 0, 0, 0, 0, 0];
    const currentUserUID = userUID
    snapshot.forEach(doc => {
        const data = doc.data();
        console.log('Document data:', data);

        // Check if the current item's ID matches any ID in the userItemIds array
        if (data.userUID === currentUserUID) {
            const dayIndex = data.dayIndex;
            trafficData[dayIndex] += data.views; // Accumulate views for the day
        }
    });

    // Ensure trafficChart is initialized before trying to update
    if (trafficChart && trafficChart.data && trafficChart.data.datasets) {
        // Update the traffic chart
        trafficChart.data.datasets[0].data = trafficData;
        trafficChart.update();
    } else {
        console.error('Traffic chart is not initialized.');
    }
});






const salesCtx = document.getElementById('salesChart')?.getContext('2d');
let salesChart;

if (salesCtx) {
    salesChart = new Chart(salesCtx, {
        type: 'bar',
            data: {
                labels: ['dog Food', 'Dog Accessories', 'Dog Toys'],
                datasets: [{
                    label: 'Profits Earned',
                    data: [0,0,0],
                    backgroundColor: [
                        'rgba(255, 99, 132, 0.6)',
                        'rgba(54, 162, 235, 0.6)',
                        'rgba(75, 192, 192, 0.6)'
                    ],
                    borderColor: [
                        'rgba(255, 99, 132, 1)',
                        'rgba(54, 162, 235, 1)',
                        'rgba(75, 192, 192, 1)'
                    ],
                    borderWidth: 1
                }]
            },
        options: {
            responsive: true,
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
}

// Real-time listener for the sales data collection
const salesRef = collection(db, 'sales');
    onSnapshot(salesRef, (snapshot) => {
        // Reset category data
        let profitData = {
            'dogFood': 0,
            'dogAccessories': 0,
            'dogToys': 0
        };

    const currentUserUID = userUID; // Replace this with the UID of the current logged-in user or dynamically set it

    snapshot.forEach(doc => {
            const data = doc.data();
            console.log('Sales data:', data);
            if (data.userUID === currentUserUID) {
                const category = data.category
                console.log(category)
                profitData[data.category] += data.profit; // Accumulate profit for the category
            }
        });

    // Update the sales chart if initialized
    if (salesChart && salesChart.data && salesChart.data.datasets) {
            
            salesChart.data.datasets[0].data = [
                profitData['dogFood'],
                profitData['dogAccessories'],
                profitData['dogToys']
            ];
            salesChart.update();
            console.log('Chart updated with new profit data:', profitData);
        } else {
            console.error('Sales chart is not initialized.');
        }
    });
    
</script>

</body>
</html>
